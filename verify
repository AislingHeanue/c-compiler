#!/bin/bash

### May change for other devices/languages being used ###
root_test_path="../../nlsandler/writing-a-c-compiler-tests"
binary="target/release/c-compiler"
###
if [[ -n "$COMMENTS" ]]; then
	binary="$binary --comments"
fi

chapter=$1
stage=$2
name=$(echo "$3" | cut -d. -f1)

first_file=$(find "$root_test_path/tests/chapter_$chapter" -mindepth 2 -maxdepth 4 -name "$name.c")
clone_file=${first_file/.c/_client.c}

if [[ -z $first_file ]]; then
	echo file not found
	exit 1
fi

if [ -f $clone_file ]; then
	file=$(echo "$first_file $clone_file")
else
	file=$first_file
fi
bat $file

case $stage in
lex)
	bash -c "$binary $file --lex"
	;;
parse)
	# Pretty print the output tree as something like C.
	bash -c "$binary $file --parse > out && bat -l c < out; rm out"
	;;
validate)
	# Pretty print the output tree as something like C.
	bash -c "$binary $file --validate > out && bat -l c < out; rm out"
	;;
tacky)
	bash -c "$binary $file --tacky"
	;;
codegen)
	bash -c "$binary $file --codegen"
	;;
run)
	output_name=${first_file%.c}
	result=$(bash -c "$binary $file")
	# Run the outputted binary (if it exists)
	$output_name
	# Store the return code
	result_code=$?
	echo
	echo "Result of $name: $result_code"

	echo "Code:"
	# Print the generated assembly code
	bash -c "$binary $file -S" | bat -l asm --paging=never
	;;
esac
